<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx编译安装</title>
    <url>/2022/03/20/Nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="检查安装环境"><a href="#检查安装环境" class="headerlink" title="检查安装环境"></a>检查安装环境</h1><ul>
<li><p>我们在安装不同的工具软件的时候，需要安装插件的环境关系</p>
<p>​        检查系统版本：<code>cat /etc/redhat-release</code></p>
<p>​        查看是否已安装<code>wget: rpm -qa|wget</code></p>
<p>​        (注： Linux系统中的wget是一个下载文件的工具)</p>
</li>
<li><p>​    否则（结果显示空白）安装：<code>yum -y install wget</code></p>
<p>​        安装g编译器：默认的云服务器都是会安装的。</p>
<p>​        查看是否已安装编译器：<code>rpm -qa|gcc</code></p>
<p>​        否则（结果显示空白）安装：<code>yum -y install gcc gcc-c++</code></p>
</li>
<li><p>为什么要装gcc编译器？</p>
<p>​    gcc是c语言编译器<br>​    而我们的nginx的编码语言就是c语言</p>
<p>​    使用gcc编译器可以编译语言代码为可执行程序</p>
</li>
</ul>
<h1 id="安装-nginx依赖"><a href="#安装-nginx依赖" class="headerlink" title="安装 nginx依赖"></a>安装 nginx依赖</h1><ol>
<li><p>nginx的Rewrite模块和HTTP核心模块会使用到PRE正则表达式语法</p>
<p>yum -y install pcre pcre-devel</p>
</li>
<li><p>nginx的各种模块中需要使用gzip压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install zlib zlib-devel</span><br></pre></td></tr></table></figure></li>
<li><p>安全套接字层密码库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install openssl openssI-devel</span><br></pre></td></tr></table></figure>

<h2 id="全部依赖："><a href="#全部依赖：" class="headerlink" title="全部依赖："></a>全部依赖：</h2></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc gcc-c++ make unzip pcre pcre-devel zlib zlib-devel libxml2 libxml2-devel  readline readline-devel ncurses ncurses-devel perl-devel perl-ExtUtils-Embed openssl-devel -y</span><br></pre></td></tr></table></figure>

<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><ol>
<li>下载 nginx</li>
</ol>
<p>​    wget <a href="http://nginx.org/download/nginx-1.14.0.tar.gz">http://nginx.org/download/nginx-1.14.0.tar.gz</a> 或者下载好直接上传</p>
<p>​    解压：<code>tar-zxvf nginx-1.14.0.tar.gz</code></p>
<ol start="2">
<li>解压nginx</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd nginx-1.14.0</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220320122137.png?raw=true" alt="20220320122137.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/src/nginx --with-http_ssl_module --with-http_stub_status_module --with-pcre --with-http_spdy_module</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">编译选项官方提供的有：</span><br><span class="line">–prefix=path 定义一个目录来保存你的nginx的提供功能的文件夹，就这好比我们安装软件的时候软件存放的目录，如果我们在编译的不指定安装位置，那么默认的位置/usr/local/nginx 目录</span><br><span class="line">–sbin-path=path 设置nginx执行脚本的位置，这里如果设置在path变量里面，就可以在bash环境下，任意使用nginx命令，默认位置prefix/sbin/nginx 注意这里的prefix是</span><br><span class="line">在配置文件里面配置的路径</span><br><span class="line">–conf-path=path 配置nginx配置文件的路径，如果不指定这个选项，那么配置文件的默认路径就会是 prefix/conf/nginx.conf</span><br><span class="line">–pid-path =path 配置nginx.pid file的路径，一般来说，进程在运行的时候的时候有一个进程id，这个id会保存在pid file里面，默认的pid file的放置位置是prefix/logs/nginx.pid</span><br><span class="line">–error-log-path=path 设置错误日志的存放路径，如果不指定，就默认 prefix/logs/error.log</span><br><span class="line">–http-log-path= path 设置http访问日志的路径，如果不指定，就默认 prefix/logs/access.log</span><br><span class="line">–user=name 设置默认启动进程的用户，如果不指定，就默认 nobody</span><br><span class="line">–group=name 设置这个用户所在的用户组，如果不指定，依然是nobody</span><br><span class="line">这些是我们常用的编译选项，其他的可以均保持默认，如需特殊指定，可上nginx官网查阅 http://nginx.org/en/docs/configure.html</span><br><span class="line">下面是一些不常用的选项</span><br><span class="line">–with-http_ssl_module -开启HTTP SSL模块，使NGINX可以支持HTTPS请求。需要安装了OPENSSL</span><br><span class="line">–with-http_flv_module</span><br><span class="line">–with-http_stub_status_module - 启用 “server status” 页(可有可无)</span><br><span class="line">–without-http_gzip_module - 禁用 ngx_http_gzip_module. 如果启用，需要 zlib 。</span><br><span class="line">–without-http_ssi_module - 禁用 ngx_http_ssi_module</span><br><span class="line">–without-http_referer_module - 禁用 ngx_http_referer_module</span><br><span class="line">–without-http_rewrite_module - 禁用 ngx_http_rewrite_module. 如果启用需要 PCRE 。</span><br><span class="line">–without-http_proxy_module - 禁用 ngx_http_proxy_module</span><br><span class="line">–without-http_fastcgi_module - 禁用 ngx_http_fastcgi_module</span><br><span class="line">–without-http_memcached_module - 禁用 ngx_http_memcached_module</span><br><span class="line">–without-http_browser_module - 禁用 ngx_http_browser_module</span><br><span class="line">–http-proxy-temp-path=PATH - Set path to the http proxy temporary files</span><br><span class="line">–http-fastcgi-temp-path=PATH - Set path to the http fastcgi temporary files</span><br><span class="line">–without-http - 禁用 HTTP server（用作代理或反向代理）</span><br><span class="line">–with-mail - 启用 IMAP4/POP3/SMTP 代理模块</span><br><span class="line">–with-mail_ssl_module - 启用 ngx_mail_ssl_module</span><br><span class="line">–with-openssl=DIR - Set path to OpenSSL library sources</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编译并安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>创建并设置 nginx运行账号（本章节是为了提高服务器的访问权限控制——可跳过，不影响个人使用）</p>
<p>group add nginx</p>
<p>user add -M -g nginx -s /sbin/nologin nginx（手动创建一个用户，不想让用户登录系统）</p>
<p>cd /usr/local/src/nginx/config</p>
<p>(注: M：不要自动建立用户的登入目录。)</p>
<p>s是指定用户登入后所使用的she11。默认值为/bin/bash。如果不想让用户登录系统可以用-s /sbin/nologin此用户就不可以登录系统</p>
</li>
<li><p>设置 nginx为系统服务</p>
</li>
</ol>
<pre><code>  在文件夹/lib/systemd/system新建文件 nginx.service

  文件创建：touch nginx.service

  vim /lib/systemd/system/nginx.service
</code></pre>
<p>   写入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/src/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/local/src/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/src/nginx/sbin/nginx -s stop</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>启动nginx</p>
<p>systemctl start nginx</p>
<p>如果出现</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220320124604.png?raw=true" alt="20220320124604.png"></p>
<p>那么输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>再重新启动nginx即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>

<h1 id="nginx的config文件语法高亮"><a href="#nginx的config文件语法高亮" class="headerlink" title="nginx的config文件语法高亮"></a>nginx的config文件语法高亮</h1><ol>
<li>进入nginx的源码文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/nginx-1.18.0/contrib/vim/syntax</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将该文件夹下的nginx.vim复制到<del>/.vim/syntax/文件夹下，并且在</del>/.vim/filetype.vim文件中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;au BufRead,BufNewFile /usr/local/src/nginx/conf/* set ft=nginx&quot; &gt;&gt; /root/.vim/filetype.vim</span><br></pre></td></tr></table></figure>

<h1 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h1><p><a href="https://xinx.top/archives/45.html">https://xinx.top/archives/45.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install kernel-headers</span><br></pre></td></tr></table></figure>

<p>Nginx官网 启动脚本</p>
<p><a href="https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/">https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vps</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title>docker从安装到使用的常用命令</title>
    <url>/2022/03/21/docker%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql百题心得</title>
    <url>/2022/04/07/mysql%E7%99%BE%E9%A2%98%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>##知识点补充</p>
<center>SQL的思想</center>

<center>面向集合的思想</center>

<p>​    SQL是为查询和管理关系型数据库中的数据而专门设计的一种标准语言。我们通常认为的关系型是说的数据库中表与表的关系，这个理解是有问题的，这里的关系其实是数学术语上的关系。<br>为什么这么说？<br>​    ==因为关系型数据库是以关系模型为基础==，而关系模型是以集合论和谓词逻辑两大数学理论为依据的。集合论中，关系是集合的一种表示。在关系模型中，==关系是相关信息的一个集合==，反映到数据库中就是一张表。<br>我们知道==集合是不关心顺序的==。表作为一个集合，==它本身并没有顺序的概念==。在很久之前有人问过，我按顺序插入id=1,2,3的记录，为什么查处来时和插入的顺序不一致。很多人都有这样的认为，就是从表选取记录时，记录是按插入顺序或主键的大小顺序返回的。在SQL评审中也经常遇到不带ORDERBY 的LIMIT语句。<br>​    这么写实际上是有问题的，不带ORDER BY子句的查询只表示从集合中查询数据，返回的结果是不确定的，之所以结果看起来对的，是因为MySQL访问数据的方式和你的需求恰巧一致了，表上索引或数据的变化都可能会影响到你的结果。因此要牢记不要为表中的行假定任何特定的顺序，==确定需要按某个顺序取数时显式的加上ORDER BY==。<br>​    很多人都是先有面向过程和面向对象的对象的编程经验后开始SQL编程的，这往往限制了对SQL问题的思考。<br>​    SQL和传统编程语言最大的区别是它以关系模型和集合论为背景。在SQL编程中最能体现面向过程和面向集合区别的就是对游标的使用，面向过程的编程同样体现在使用中对子查询、派生表、以及临时表的过多依赖。许多人的编程经验是把一个任务细分成许多小任务，而后按一定的顺序来实现它们或先把需要的数据存储在各个临时表或先包含在派生表里再做关联处理。==但如果按这种方式处理SQL编程，可能只会得到平庸的结果。==<br>​    这类实现往往是代码很长，很难维护，欠缺灵活性，而最大问题是由于相对固化的处理逻辑限制了优化器的优化空间，==大多数情况下这类面向过程的实现在性能上都远不如面向集合的实现==。编写高效的SQL需要我们跳出原有面向过程的思维方式，换一种思维方式去思考问题。==可以总结为：解决SQL问题时要关注的是获取“什么”，而不是“如何”去获取==。SQL是一门注重思想而非技巧的语言。</p>
<p><a href="https://www.cnblogs.com/Alight/p/3649412.html">https://www.cnblogs.com/Alight/p/3649412.html</a></p>
<center>SQL语句的执行顺序</center>
有些情况下Select 语句没有加 “Order By”，返回的数据是不确定的
这种问题碰到不止几次了。追根寻底， Select 语句如果不加 “Order By”， MySQL会怎么排序呢？

<ul>
<li>不能依赖 MySQL 的默认排序</li>
<li>如果你想排序，总是加上 Order By</li>
<li>GROUP BY 强加了 Order By （这与标准语法冲突，如果要避免，请使用 ORDER BY NULL）这里我有疑问，到底强加了何种 Order by<br>对于 MyISAM 表<br>MySQL Select 默认排序是按照物理存储顺序显示的。（不进行额外排序）.也就是说SELECT * FROM tabl – 会产生“表扫描”。如果表没有删除、替换、更新操作，记录会显示为插入的顺序。<br>对于 InnoDB 表<br>同样的情况，会按主键的顺序排列。再次强调，这只是潜规则（artifact of the underlying implementation：怎么翻译？），不靠谱的。<br>理解与推测<br>“Select” 不加 “Order by”时， MySQL 会尝试以尽可能快的方法（MySQL 实际的方法不见得快）返回数据。由于访问主键、索引大多数情况会快一些（在Cache里）所以返回的数据有可能以主键、索引的顺序输出，<br>这里并不会真的进行排序，主要是由于主键、索引本身就是排序放到内存的，所以连续输出时可能是某种序列。<br>在一些情况下消耗硬盘寻道时间最短的数据会先返回。如果只查询单个表，在特殊的情况下是有规律的。<br>最后总结：<br>“Order By 是要加的”<br><a href="https://blog.csdn.net/caomiao2006/article/details/52144949">https://blog.csdn.net/caomiao2006/article/details/52144949</a></li>
</ul>
<center>关于 ORDER BY关键字</center>
##### 一、ORDER BY返回的是游标而不是集合

<p>SQL的理论其实是集合论，常见的类似求数据的交集、并集、差集都可以使用集合的思维来求解。集合中的行之间没有预先定义的顺序，它只是成员的一种逻辑组合，成员之间的顺序无关紧要。如下图，每一个括号里的内容就是一条记录，在没排序前，他们都是随机分布在集合中。<br>Student(ID,Name,Age)</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407110418.png?raw=true" alt="20220407110418.png"></p>
<center>Student集合</center>

<p>但是对于带有排序作用的ORDER BY子句的查询，它返回的是一个对象，其中的行按特定的顺序组织在一起，我们把这种对象称为游标。<br>如下图，经过对Student表的ID进行ORDER BY排序后，Student表变成了有序对象，也就是我们上面说的游标。<br>Student(ID,Name,Age)</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111256.png?raw=true" alt="20220407111256.png"></p>
<center>Student对象</center>



<h5 id="二、ORDER-BY子句是唯一能重用列别名的一步"><a href="#二、ORDER-BY子句是唯一能重用列别名的一步" class="headerlink" title="二、ORDER BY子句是唯一能重用列别名的一步"></a>二、ORDER BY子句是唯一能重用列别名的一步</h5><p>这里涉及SQL语句的语法顺序和执行顺序了，我们常见的SQL语法顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">DISTINCT</span> </span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">column</span><span class="operator">-</span>list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line"><span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line"><span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line"><span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line"><span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line"><span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span> </span><br><span class="line"><span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line"><span class="operator">&lt;</span>order_by_list<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>而数据库引擎在执行SQL语句并不是从SELECT开始执行，而是从FROM开始，具体执行顺序如下(关键字前面的数字代表SQL执行的顺序步骤)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="number">8</span>)<span class="keyword">SELECT</span> (<span class="number">9</span>)<span class="keyword">DISTINCT</span>  (<span class="number">11</span>)<span class="operator">&lt;</span>Top Num<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">select</span> list<span class="operator">&gt;</span>  </span><br><span class="line">(<span class="number">1</span>)<span class="keyword">FROM</span> <span class="operator">&lt;</span>left_table<span class="operator">&gt;</span>  </span><br><span class="line">(<span class="number">3</span>)<span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>right_table<span class="operator">&gt;</span> </span><br><span class="line">(<span class="number">2</span>)<span class="keyword">ON</span>  <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span> </span><br><span class="line">(<span class="number">4</span>)<span class="keyword">WHERE</span> <span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span> </span><br><span class="line">(<span class="number">5</span>)<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span> </span><br><span class="line">(<span class="number">6</span>)<span class="keyword">WITH</span> <span class="operator">&lt;</span><span class="keyword">CUBE</span> <span class="operator">|</span> <span class="keyword">RollUP</span><span class="operator">&gt;</span> </span><br><span class="line">(<span class="number">7</span>)<span class="keyword">HAVING</span> <span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span> </span><br><span class="line">(<span class="number">10</span>)<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>order_by_list<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure>

<p>从上面可以看到SELECT在HAVING后才开始执行，这个时候SELECT后面列的别名只对后续的步骤生效，而对SELECT前面的步骤是无效的。所以如果你在WHERE，GROUP BY，或HAVING后面使用列的别名均会报错。<br>我们举例测试一下。</p>
<p>示例表Customers结构及数据如下：</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111352.png?raw=true" alt="20220407111352.png"></p>
<p>1、WHERE后面不使用别名的情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">姓名 <span class="keyword">AS</span> Name, </span><br><span class="line">地址 <span class="keyword">AS</span> Address, </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">WHERE</span> 城市<span class="operator">=</span><span class="string">&#x27;广州&#x27;</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111448.png?raw=true" alt="20220407111448.png"></p>
<p>2、WHERE后面使用列别名的情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">姓名 <span class="keyword">AS</span> Name, </span><br><span class="line">地址 <span class="keyword">AS</span> Address, </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">WHERE</span> City<span class="operator">=</span><span class="string">&#x27;广州&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111512.png?raw=true" alt="20220407111512.png"></p>
<p>从返回的消息中我们可以看到，重命名后的City并不能被WHERE识别，所以才会报“列名’City’无效”的提示。<br>其他关键字大家也可以使用上述方法进行测试，下面我们测试GROUP BY和HAVING后面使用列别名的情况。<br>3、测试GROUP BY后使用列别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> City</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111540.png?raw=true" alt="20220407111540.png"></p>
<p>4、测试HAVING后使用列别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 城市 </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(City) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>5、测试ORDER BY后面使用列别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">姓名 <span class="keyword">AS</span> Name, </span><br><span class="line">地址 <span class="keyword">AS</span> Address, </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> City</span><br></pre></td></tr></table></figure>


<p>结果如下：</p>
<p> <img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111622.png?raw=true" alt="20220407111622.png"></p>
<p>从上面的几个测试示例的结果中，可以得出我们的结论是正确的：ORDER BY子句是唯一能重用列别名的一步。</p>
<h5 id="三、谨慎使用ORDER-BY-后面接数字的方式来进行排序"><a href="#三、谨慎使用ORDER-BY-后面接数字的方式来进行排序" class="headerlink" title="三、谨慎使用ORDER BY 后面接数字的方式来进行排序"></a>三、谨慎使用ORDER BY 后面接数字的方式来进行排序</h5><p>有些小伙伴为了图省事，喜欢在ORDER BY后面写数字，具体示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">姓名 <span class="keyword">AS</span> Name, </span><br><span class="line">地址 <span class="keyword">AS</span> Address, </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111701.png?raw=true" alt="20220407111701.png"></p>
<p>这样写的结果，针对当前的查询是正确没有问题的，ORDER BY后面的数字1,2,3分别代表SELECT后面的第1，第2，第3个字段(也就是Name，Address，City)。<br>可是当查询的列发生改变，忘了修改ORDER BY列表。特别是当查询语句很长时，要找到ORDER BY与SELECT列表中的哪个列相对应会非常困难。<br>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">客户ID <span class="keyword">AS</span> ID, </span><br><span class="line">姓名 <span class="keyword">AS</span> Name, </span><br><span class="line">地址 <span class="keyword">AS</span> Address, </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>由于增加了一列“客户ID”，原本的题意还是对Name，Address，City排序，但是因为使用了ORDER BY加数字，排序后的结果如下：</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111731.png?raw=true" alt="20220407111731.png"></p>
<p>得到的结果并不是我们想要的，所以请慎用ORDER BY加数字，尽量使用ORDER BY加列名或列别名。</p>
<h5 id="四、表达式不能使用ORDER-BY排序"><a href="#四、表达式不能使用ORDER-BY排序" class="headerlink" title="四、表达式不能使用ORDER BY排序"></a>四、表达式不能使用ORDER BY排序</h5><p>表表达式包括视图，内联表值函数，派生表(子查询)和公用表表达式(CTE)。<br>例如下面的视图是无效的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_Customers <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">客户ID <span class="keyword">AS</span> ID, </span><br><span class="line">姓名 <span class="keyword">AS</span> Name, </span><br><span class="line">地址 <span class="keyword">AS</span> Address, </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ID,Name,Address</span><br></pre></td></tr></table></figure>


<p>结果如下：</p>
<p> <img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111756.png?raw=true" alt="20220407111756.png"></p>
<p>这个错误是不是很熟悉？因为很多小伙伴经常喜欢在视图或子查询里面加ORDER BY，然后一执行就会报这个错。<br>根本原因不敢妄加断定，因为搜寻了很多文献资料也没给出一个具体的说法。<br>这里猜测是因为视图，内联表值函数，派生表(子查询)和公用表表达式(CTE)等返回的结果还需要进一步的去使用，加了ORDER BY进行排序是多此一举，反而会浪费系统资源。所以数据库的开发者不希望大家使用这样不规范操作。<br>所以下次就不要在表表达式里添加ORDER BY了。</p>
<h5 id="五、T-SQL中表表达式加了TOP可以使用ORDER-BY"><a href="#五、T-SQL中表表达式加了TOP可以使用ORDER-BY" class="headerlink" title="五、T-SQL中表表达式加了TOP可以使用ORDER BY"></a>五、T-SQL中表表达式加了TOP可以使用ORDER BY</h5><p>我们从第四点的报错信息中可以看到：在另外还指定了 TOP、OFFSET 或 FOR XML是可以使用ORDER BY的。</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111819.png?raw=true" alt="20220407111819.png"></p>
<p>这又是为什么呢？<br>我们还是先举个栗子给大家看一下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">客户ID <span class="keyword">AS</span> ID, </span><br><span class="line">姓名 <span class="keyword">AS</span> Name, </span><br><span class="line">地址 <span class="keyword">AS</span> Address, </span><br><span class="line">城市 <span class="keyword">AS</span> City </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> TOP <span class="number">3</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 城市) Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ID,Name,Address</span><br></pre></td></tr></table></figure>

<p>因为T-SQL中带有ORDER BY的表表达式加了TOP后返回的是一个没有固定顺序的表。因此，在这种情况下，ORDER BY子句只是为TOP选项定义逻辑顺序，就是下面这个逻辑子句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">3</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> Customers </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 城市 </span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p> <img src="https://github.com/weiqh2000/blogImages/blob/main/20220407111904.png?raw=true" alt="20220407111904.png"></p>
<p>而不保证结果集的排列顺序，因为表表达式外面至少还有一层才是我们最终需要的结果集。<br>这里的ORDER BY只对当前的子查询生效，到了主查询是不起作用的。必须在主查询末尾继续添加一个ORDER BY子句才能对结果集生效，就像我们例子中写的那样。<br>除非逻辑要求，一般情况下并不推荐大家这样巧妙的避开子查询中不能使用ORDER BY的限制。</p>
<p><a href="https://database.51cto.com/art/201912/608333.htm">https://database.51cto.com/art/201912/608333.htm</a></p>
<p>SQL常用关键字<br>    select * :<br>返回所有记录<br>    limit N :<br>返回 N 条记录<br>    offset M :<br>跳过 M 条记录, 默认 M=0, 单独使用似乎不起作用<br>    limit N,M :<br>相当于 limit M offset N , 从第 N 条记录开始, 返回 M 条记录<br>    ORDER BY :<br>释：该关键字用于对结果集按照一列或者多个列进行排序<br>该关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以在SQL后添加DESC关键字<br>    SELECT DISTINCT :<br>在表中，一个列可能会包含多个重复值，有时也许希望仅仅列出不同（distinct）的值。<br>DISTINCT 关键词用于返回唯一不同的值。<br>使用该关键字必须指定<column-name> 并且必须要紧跟在SELECT关键字之后<br>例：<br><code>SELECT DISTINCT &lt;column_name&gt; FROM &lt;table_name&gt;</code><br>    SQL Aggregate函数 :<br>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。<br>有用的 Aggregate 函数：<br>•    AVG() - 返回平均值<br>•    COUNT() - 返回行数<br>•    FIRST() - 返回第一个记录的值<br>•    LAST() - 返回最后一个记录的值<br>•    MAX() - 返回最大值<br>•    MIN() - 返回最小值<br>•    SUM() - 返回总和</p>
<p>    WHERE :<br>子句用于提取那些满足指定条件的记录。<br>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>,<span class="operator">&lt;</span>column_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span> <span class="operator">&lt;</span>operator<span class="operator">&gt;</span> <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>



<center>SQL百题(牛客)</center>



<p><img src="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png" alt="img"></p>
<p>SQL1 查找最晚入职员工</p>
<p><a href="https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f">https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f</a></p>
<p>题解：<br>最晚入职的员工可能会有多人<br>我们使用集合的思想解题就是：查出整张表与整表的hire_date字段的最大值的交集<br>即:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> hire_date <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(hire_date) <span class="keyword">from</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>




<p>SQL2 查找入职员工时间排名倒数第三的员工所有信息</p>
<p><a href="https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c">https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c</a></p>
<p>题解<br>查入职员工表，通过where过滤时间，所以还要使用子查询查出时间排名倒数第三的员工；但是时间倒数第三的员工可能不止一个，通过<code>DISTINCT</code>关键字过滤掉重复出现的时间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> hire_date <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> hire_date <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> limit <span class="number">2</span>,<span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> hire_date <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> limit <span class="number">2</span>,<span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>SQL3 查找当前薪水详情以及部门编号dept_no</p>
<p><a href="https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b">https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b</a></p>
<p>题解<br>入职时间相同的员工可能有多人</p>
]]></content>
      <categories>
        <category>心得</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>myTest</title>
    <url>/2021/12/11/myTest/</url>
    <content><![CDATA[<p>My first test article.</p>
]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title>vps一键DD</title>
    <url>/2022/03/19/vps%E4%B8%80%E9%94%AEdd%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><p>​    腾讯云自带的一些组件，会阻止我们DD安装操作系统（安装过程会报错，无法正确写入进磁盘），所以在DD安装操作系统前，必须要禁用、删除掉这些组件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop tat_agent</span><br><span class="line">systemctl disable tat_agent</span><br><span class="line">rm -rf /etc/systemd/system/tat_agent.service</span><br><span class="line">rm -fr /usr/local/qcloud </span><br><span class="line"> </span><br><span class="line">ps -A | grep agent</span><br><span class="line"># 检查看是否还有腾讯云组件</span><br><span class="line"># kill 这个进程</span><br></pre></td></tr></table></figure>

<p>​    所有腾讯云组件都删除后，就可以DD安装Linux/Windows了.    </p>
<p>​    在使用 Centos 系统中使用 DD脚本，出现该错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Press any key to continue...Error! Not Found grub.</span><br></pre></td></tr></table></figure>

<p>​    Centos下的 grub 是在 /boot 下的 grub2 目录下 所以无法安装成功，重装切换到 Ubuntu 系统就不会出现该错误</p>
<p>​    腾讯云请先切换 Ubuntu 的镜像源至中科大镜像源，使用默认镜像源会导致下载缓慢</p>
<ul>
<li><h3 id="安装脚本所需的组件"><a href="#安装脚本所需的组件" class="headerlink" title="安装脚本所需的组件"></a>安装脚本所需的组件</h3></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Debian/Ubuntu</span></span><br><span class="line"></span><br><span class="line"> apt-get install -y xz-utils openssl gawk file curl wget </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">RedHat/CentOS</span></span><br><span class="line"></span><br><span class="line">yum install -y xz openssl gawk file curl wget</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="使用CDN下载脚本"><a href="#使用CDN下载脚本" class="headerlink" title="使用CDN下载脚本"></a>使用CDN下载脚本</h3></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://cdn.jsdelivr.net/gh/hiCasper/Shell@master/AutoReinstall.sh &amp;&amp; chmod +x AutoReinstall.sh &amp;&amp; bash AutoReinstall.sh</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="选择系统"><a href="#选择系统" class="headerlink" title="选择系统"></a>选择系统</h4></li>
</ul>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/Snipaste_2022-03-19_15-41-16.jpg?raw=true" alt="Snipaste_2022-03-19_15-41-16.jpg"></p>
<p>​    运行到这步，控制台会断开连接，之后需要到腾讯云使用VNC连接配置</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/Snipaste_2022-03-19_15-47-38.jpg?raw=true" alt="Snipaste_2022-03-19_15-47-38.jpg"></p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/Snipaste_2022-03-19_15-50-52.jpg?raw=true" alt="Snipaste_2022-03-19_15-50-52.jpg"></p>
<p>​    一路 Continue就好</p>
<p><img src="https://github.com/weiqh2000/blogImages/blob/main/Snipaste_2022-03-19_15-53-03.jpg?raw=true" alt="Snipaste_2022-03-19_15-53-03.jpg"></p>
<p>Centos </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">账号：root</span><br><span class="line">默认密码：Pwd@CentOS</span><br></pre></td></tr></table></figure>

<p>其他Liunx系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">账号：root</span><br><span class="line">默认密码：Pwd@Linux</span><br></pre></td></tr></table></figure>









<p>资料来源：</p>
<p><a href="https://www.2331314.xyz/295.html">https://www.2331314.xyz/295.html</a></p>
<p><a href="https://www.xugo.xyz/index.php/2021/12/11/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%9B%BD%E5%86%85%E8%BD%BB%E9%87%8F-dd-%E7%B3%BB%E7%BB%9F/">https://www.xugo.xyz/index.php/2021/12/11/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%9B%BD%E5%86%85%E8%BD%BB%E9%87%8F-dd-%E7%B3%BB%E7%BB%9F/</a></p>
]]></content>
      <categories>
        <category>vps</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
</search>
